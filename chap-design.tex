\chapter{METHODOLOGY}\label{chap:methodology}

This chapter presents the research methodology adopted to investigate corridor-based pathfinding on grid maps. The chapter is organised as follows. Section~\ref{sec:meth_overview} provides an overview of the proposed research framework and its constituent pipelines. Section~\ref{sec:meth_data} describes the datasets and the preprocessing pipeline used to convert raw environments into binary grid representations. Section~\ref{sec:meth_components} formalises the fundamental algorithmic components shared across all pipelines. Section~\ref{sec:meth_adaptive} details the adaptive corridor construction and strategy-selection procedure central to the Adaptive Incremental Line Search (AILS). Section~\ref{sec:meth_ils_pipeline} presents the ILS-enhanced planning pipeline. Section~\ref{sec:meth_baseline_pipeline} describes the baseline planner pipeline used for comparative evaluation. Section~\ref{sec:meth_ails_pipeline} presents the Adaptive ILS planning pipeline. Section~\ref{sec:meth_metrics} defines the evaluation metrics and experimental protocol. Section~\ref{sec:meth_summary} summarises the chapter and previews the implementation described in Chapter~\ref{chap:pipeline}.


%======================================================================
\section{Overview of Proposed Research Framework}\label{sec:meth_overview}
%======================================================================

The research framework comprised four methodological pipelines, each designed to address a specific research objective. Together, the pipelines formed a progressive investigation: from establishing classical baselines, through corridor-constrained search, to adaptive corridor construction, and finally to planning-to-flight integration on an autonomous drone platform. Figure~\ref{fig:framework_overview} illustrates the overall framework and the relationships among the four pipelines.

\begin{figure}[htb!]
\centering
\resizebox{0.95\textwidth}{!}{%
\begin{tikzpicture}[
    >=Stealth,
    node distance=1.0cm and 0.6cm,
    dsbox/.style={rectangle, draw, fill=blue!8, minimum width=2.0cm, minimum height=0.7cm,
                  font=\footnotesize, rounded corners=2pt, align=center},
    prepbox/.style={rectangle, draw, fill=orange!12, minimum width=10.0cm, minimum height=0.8cm,
                    font=\small\bfseries, rounded corners=3pt, align=center},
    pipebox/.style={rectangle, draw, thick, fill=#1, minimum width=3.4cm, minimum height=2.6cm,
                    rounded corners=4pt, align=center, font=\small},
    pipetitle/.style={font=\small\bfseries, align=center},
    pipedesc/.style={font=\scriptsize, align=center, text width=3.0cm},
    metricbox/.style={rectangle, draw, fill=green!8, minimum width=10.0cm, minimum height=0.8cm,
                      font=\small\bfseries, rounded corners=3pt, align=center},
    arrow/.style={->, thick, >=Stealth},
    darrow/.style={->, thick, >=Stealth, dashed},
]

% --- Datasets row ---
\node[dsbox] (ds1) {DS1\\[-1pt]\scriptsize Fixed-Size};
\node[dsbox, right=0.4cm of ds1] (ds2) {DS2\\[-1pt]\scriptsize Variable-Size};
\node[dsbox, right=0.4cm of ds2] (ds3) {DS3\\[-1pt]\scriptsize Topology-Varied};
\node[dsbox, right=0.4cm of ds3] (ds4) {DS4\\[-1pt]\scriptsize Satellite-Derived};

% Datasets label
\node[above=0.15cm of ds2.north east, font=\small\bfseries] {Datasets};

% --- Preprocessing ---
\node[prepbox, below=0.9cm of $(ds2.south)!0.5!(ds3.south)$] (preproc) {Preprocessing Pipeline (Steps 1--9)};

% Arrows from datasets to preprocessing
\foreach \ds in {ds1, ds2, ds3, ds4}{
    \draw[arrow] (\ds.south) -- (preproc.north -| \ds.south);
}

% Label for output
\node[below=0.15cm of preproc.south, font=\scriptsize\itshape] (prepout) {Binary Occupancy Grid $G = (V, E, w)$ + Start/Goal};

% --- Four Pipelines ---
\node[pipebox=red!8, below=1.4cm of preproc.south west, xshift=0.2cm] (p1) {};
\node[pipetitle, anchor=north] at ([yshift=-0.15cm]p1.north) {Pipeline 1};
\node[pipedesc, anchor=north] at ([yshift=-0.55cm]p1.north) {Baseline Planner\\[2pt]\scriptsize Full-grid search\\(A*, Dijkstra, BFS,\\DFS, Best-First)\\[2pt]\scriptsize No corridor};

\node[pipebox=cyan!8, right=0.5cm of p1] (p2) {};
\node[pipetitle, anchor=north] at ([yshift=-0.15cm]p2.north) {Pipeline 2};
\node[pipedesc, anchor=north] at ([yshift=-0.55cm]p2.north) {ILS-Enhanced\\[2pt]\scriptsize Uniform-width\\corridor + incremental\\expansion\\[2pt]\scriptsize Fixed $w_0$};

\node[pipebox=violet!8, right=0.5cm of p2] (p3) {};
\node[pipetitle, anchor=north] at ([yshift=-0.15cm]p3.north) {Pipeline 3};
\node[pipedesc, anchor=north] at ([yshift=-0.55cm]p3.north) {Adaptive ILS\\[2pt]\scriptsize Density-adaptive\\corridor via integral\\images\\[2pt]\scriptsize Variable $r(p)$};

\node[pipebox=yellow!12, right=0.5cm of p3] (p4) {};
\node[pipetitle, anchor=north] at ([yshift=-0.15cm]p4.north) {Pipeline 4};
\node[pipedesc, anchor=north] at ([yshift=-0.55cm]p4.north) {Planning-to-Flight\\[2pt]\scriptsize Drone deployment\\via DroneKit /\\ROS--MAVROS\\[2pt]\scriptsize ArduPilot};

% Arrows from preprocessing to pipelines
\foreach \p in {p1, p2, p3, p4}{
    \draw[arrow] (preproc.south -| \p.north) -- (\p.north);
}

% --- Evaluation Metrics ---
\node[metricbox, below=0.9cm of $(p2.south)!0.5!(p3.south)$] (metrics) {Evaluation Metrics};
\node[below=0.1cm of metrics.south, font=\scriptsize\itshape, align=center] (metdesc) {Execution Time \,\textbar\, Visited Nodes \,\textbar\, Path Length \,\textbar\, Optimality Rate \,\textbar\, Corridor Efficiency};

% Arrows from pipelines to metrics
\foreach \p in {p1, p2, p3, p4}{
    \draw[arrow] (\p.south) -- (metrics.north -| \p.south);
}

% --- Progressive arrows between pipelines ---
\draw[darrow, blue!60] ([yshift=-0.15cm]p1.east) -- ([yshift=-0.15cm]p2.west) node[midway, above, font=\tiny\itshape] {+corridor};
\draw[darrow, blue!60] ([yshift=-0.15cm]p2.east) -- ([yshift=-0.15cm]p3.west) node[midway, above, font=\tiny\itshape] {+adaptive};
\draw[darrow, blue!60] ([yshift=-0.15cm]p3.east) -- ([yshift=-0.15cm]p4.west) node[midway, above, font=\tiny\itshape] {+flight};

\end{tikzpicture}%
}
\caption{Overview of the proposed research framework. The four pipelines share common grid representations and evaluation metrics but differ in their search-space restriction strategy.}
\label{fig:framework_overview}
\end{figure}

The four pipelines were defined as follows:

\begin{enumerate}[label=\textbf{Pipeline~\arabic*:}, leftmargin=3.5cm]

\item \textbf{Baseline Planner Pipeline.} This pipeline executed classical pathfinding algorithms---A*, Dijkstra's algorithm, Breadth-First Search (BFS), Depth-First Search (DFS), and Greedy Best-First Search---on the full grid without any search-space restriction. The purpose was to establish performance baselines against which corridor-based methods were compared. The pipeline is detailed in Section~\ref{sec:meth_baseline_pipeline}.

\item \textbf{ILS-Enhanced Planning Pipeline.} This pipeline integrated the Incremental Line Search (ILS) optimisation with each of the classical algorithms listed above. ILS constrained the search to a corridor centred on a Bresenham reference line connecting start and goal, and expanded the corridor incrementally when no path was found within the current band. The pipeline is detailed in Section~\ref{sec:meth_ils_pipeline}.

\item \textbf{Adaptive ILS Planning Pipeline.} This pipeline extended the ILS approach by introducing per-point density estimation via integral images and a variable-width corridor whose radius at each reference-line cell was a closed-form function of the local obstacle density. Three corridor strategies---Base, Standard, and Predictive---were provided and selected automatically. The pipeline is detailed in Section~\ref{sec:meth_ails_pipeline}.

\item \textbf{Planning-to-Flight Pipeline.} This pipeline deployed the pathfinding algorithms on an autonomous drone platform via DroneKit and ROS/MAVROS integration with ArduPilot. The implementation details and flight procedures are deferred to Chapter~\ref{chap:pipeline}, as they pertain to system integration rather than algorithmic methodology.

\end{enumerate}

All four pipelines shared the same grid representation, preprocessing procedure, and evaluation metrics, thereby ensuring that performance differences were attributable solely to the search strategy employed.


%======================================================================
\section{Data Description and Preprocessing Pipeline}\label{sec:meth_data}
%======================================================================

This section describes the four datasets used throughout the experimental evaluation and the preprocessing pipeline applied to convert raw environments into binary occupancy grids.

%----------------------------------------------------------------------
\subsection{Dataset Descriptions}\label{subsec:datasets}
%----------------------------------------------------------------------

Four datasets were employed, denoted DS1--DS4. Each dataset targeted a specific aspect of the evaluation: grid-based benchmarking at fixed size, scalability analysis across grid dimensions, robustness across obstacle topologies, and real-world applicability.

\begin{table}[htb!]
\centering
\caption{Summary of Datasets DS1--DS4}
\label{tab:datasets}
\begin{tabular}{|p{1.2cm}|p{2.8cm}|p{2.5cm}|p{2.0cm}|p{1.8cm}|p{2.5cm}|}
\hline
\textbf{Label} & \textbf{Description} & \textbf{Grid Size(s)} & \textbf{Densities} & \textbf{Maps} & \textbf{Source} \\
\hline
DS1 & Synthetic random grids (fixed size) & $200 \times 200$ & 10\%, 20\%, 30\% & 2{,}000 per density (6{,}000 total) & Generated (Bernoulli) \\
\hline
DS2 & Synthetic grids (variable size) & $50 \times 50$ to $500 \times 500$ (8 sizes) & 10\%--40\% (5\% steps) & 100 start--goal pairs per config & Generated (multiple patterns) \\
\hline
DS3 & Topology-varied grids & $200 \times 200$ & 10\%--40\% & 50--200 per config & Generated (5 patterns) \\
\hline
DS4 & Satellite-derived grid & Native resolution & Natural & 1 & Satellite image at $(5.31361,\; 100.26908)$ \\
\hline
\end{tabular}
\end{table}

\textbf{DS1: Synthetic Random Grids (Fixed Size).} This dataset was used in the ILS study \citep{Elshahed2025ILS}. A total of 6{,}000 binary occupancy grids of size $200 \times 200$ were generated. For each of three obstacle densities---10\%, 20\%, and 30\%---2{,}000 maps were produced. Obstacles were placed independently at each cell according to a Bernoulli distribution with probability equal to the target density. The start position was fixed at the top-left corner of the grid and the goal at the bottom-right corner. To prevent trivial disconnection, the top row and the rightmost column were kept obstacle-free. All grids were post-processed to ensure reachability between start and goal. An 8-connected neighbourhood model was used, permitting horizontal, vertical, and diagonal movement.

\textbf{DS2: Synthetic Grids (Variable Size).} This dataset was used in the AILS study \citep{Elshahed2025AILS}. Grids were generated at eight sizes: $50 \times 50$, $100 \times 100$, $150 \times 150$, $200 \times 200$, $250 \times 250$, $300 \times 300$, $400 \times 400$, and $500 \times 500$. Seven obstacle densities were tested: 10\%, 15\%, 20\%, 25\%, 30\%, 35\%, and 40\%, in increments of 5\%. For each grid-size and density combination, 100 random start--goal pairs were sampled; pairs for which no valid path existed were discarded before timing began, so that every measured instance had a valid solution. An 8-connected neighbourhood model was used.

\textbf{DS3: Topology-Varied Grids.} Also used in the AILS study, this dataset introduced five distinct obstacle topologies on $200 \times 200$ grids: \emph{Random} (uniform independent placement), \emph{Clustered} (Gaussian-centred obstacle groups), \emph{Maze} (corridors and walls generated via recursive division), \emph{Room} (rectangular rooms connected by narrow doorways), and \emph{Open} (sparse, low-density placement). For each topology-density combination, 50--200 random start--goal pairs were evaluated.

\textbf{DS4: Satellite-Derived Grid.} A single real-world grid was derived from a satellite image at coordinates $(5.31361,\; 100.26908)$. The image was converted into a binary occupancy grid through the preprocessing pipeline described in Section~\ref{subsec:preprocessing}. This dataset was used to assess the applicability of ILS to non-synthetic environments.

%----------------------------------------------------------------------
\subsection{Preprocessing Pipeline}\label{subsec:preprocessing}
%----------------------------------------------------------------------

All grid maps, whether synthetically generated or derived from imagery, underwent a standardised preprocessing pipeline comprising the following steps:

\begin{enumerate}[label=\textbf{Step~\arabic*:}]

\item \textbf{Image Acquisition.} For DS4, the satellite image was acquired at the specified coordinates. For DS1--DS3, this step was replaced by procedural grid generation.

\item \textbf{Greyscale Conversion.} Colour images were converted to 8-bit greyscale.

\item \textbf{Binary Thresholding.} Each pixel was classified as either traversable ($\text{value} \geq 128$) or obstacle ($\text{value} < 128$) using a fixed threshold of 128. This threshold was applied uniformly across all image-derived grids.

\item \textbf{Grid Construction.} The binary image was mapped to an occupancy grid $G = (V, E, w)$, where each pixel corresponded to one vertex $v \in V$, and edges connected each vertex to its valid neighbours under the chosen connectivity model (8-connected for DS1--DS3; 4-connected for the drone implementation described in Chapter~\ref{chap:pipeline}).

\item \textbf{Obstacle Density Verification.} For synthetic grids (DS1--DS3), the actual obstacle density of each generated map was verified against the target density. Maps whose actual density deviated by more than 1\% from the target were regenerated.

\item \textbf{Start and Goal Assignment.} Start and goal positions were assigned according to the dataset specification: fixed corners for DS1, random sampling for DS2--DS3, and user-specified positions for DS4.

\item \textbf{Reachability Check.} A breadth-first traversal from the start position was performed to confirm that the goal was reachable. Unreachable instances were discarded (DS2--DS3) or flagged (DS1, DS4).

\item \textbf{Integral Image Computation (AILS Only).} For experiments involving AILS (Pipelines~3), a summed-area table $I(x,y) = \sum_{x' \leq x,\; y' \leq y} \mathrm{occ}(v_{x',y'})$ was precomputed from the occupancy grid in $O(|V|)$ time. This integral image enabled $O(1)$ local density queries during corridor construction (see Section~\ref{sec:meth_adaptive}).

\item \textbf{Output.} The preprocessed grid, together with start/goal coordinates and (where applicable) the integral image, was passed to the appropriate planning pipeline.

\end{enumerate}

Figure~\ref{fig:preprocessing} illustrates the preprocessing pipeline.

\begin{figure}[htb!]
\centering
\resizebox{0.88\textwidth}{!}{%
\begin{tikzpicture}[
    >=Stealth,
    node distance=0.55cm,
    stepbox/.style={rectangle, draw, thick, fill=blue!6, minimum width=6.5cm, minimum height=0.75cm,
                    rounded corners=3pt, font=\small, align=center},
    startbox/.style={rectangle, draw, thick, fill=green!10, minimum width=6.5cm, minimum height=0.75cm,
                     rounded corners=3pt, font=\small, align=center},
    endbox/.style={rectangle, draw, thick, fill=orange!10, minimum width=6.5cm, minimum height=0.75cm,
                   rounded corners=3pt, font=\small, align=center},
    condbox/.style={diamond, draw, thick, fill=yellow!10, minimum width=1.8cm, minimum height=0.9cm,
                    font=\scriptsize, align=center, aspect=2.5},
    arrow/.style={->, thick, >=Stealth},
    note/.style={font=\scriptsize\itshape, text=gray!70!black},
]

% --- Step 1 ---
\node[startbox] (s1) {\textbf{Step 1:} Image Acquisition / Procedural Generation};
\node[note, right=0.3cm of s1] {DS4: satellite image; DS1--DS3: synthetic};

% --- Step 2 ---
\node[stepbox, below=0.55cm of s1] (s2) {\textbf{Step 2:} Greyscale Conversion};
\node[note, right=0.3cm of s2] {Colour $\to$ 8-bit greyscale};

% --- Step 3 ---
\node[stepbox, below=0.55cm of s2] (s3) {\textbf{Step 3:} Binary Thresholding};
\node[note, right=0.3cm of s3] {Threshold $= 128$};

% --- Step 4 ---
\node[stepbox, below=0.55cm of s3] (s4) {\textbf{Step 4:} Grid Construction};
\node[note, right=0.3cm of s4] {$G = (V, E, w)$; 8- or 4-connected};

% --- Step 5 ---
\node[stepbox, below=0.55cm of s4] (s5) {\textbf{Step 5:} Obstacle Density Verification};
\node[note, right=0.3cm of s5] {Synthetic only; $\leq 1\%$ deviation};

% --- Step 6 ---
\node[stepbox, below=0.55cm of s5] (s6) {\textbf{Step 6:} Start and Goal Assignment};
\node[note, right=0.3cm of s6] {Fixed / random / user-specified};

% --- Step 7 ---
\node[stepbox, below=0.55cm of s6] (s7) {\textbf{Step 7:} Reachability Check};
\node[note, right=0.3cm of s7] {BFS from start to goal};

% --- Step 8 (conditional) ---
\node[condbox, below=0.85cm of s7] (cond) {AILS\\pipeline?};

\node[stepbox, fill=violet!8, below right=0.7cm and 2.0cm of cond] (s8) {\textbf{Step 8:} Integral Image Computation};
\node[note, right=0.3cm of s8] {Summed-area table; $O(|V|)$};

% --- Step 9 ---
\node[endbox, below=2.2cm of cond] (s9) {\textbf{Step 9:} Output};
\node[note, below=0.2cm of s9] {Grid + start/goal + integral image};

% --- Arrows ---
\draw[arrow] (s1) -- (s2);
\draw[arrow] (s2) -- (s3);
\draw[arrow] (s3) -- (s4);
\draw[arrow] (s4) -- (s5);
\draw[arrow] (s5) -- (s6);
\draw[arrow] (s6) -- (s7);
\draw[arrow] (s7) -- (cond);

% Conditional branches
\draw[arrow] (cond.east) -- ++(0.8cm,0) |- node[pos=0.25, above, font=\scriptsize] {Yes} (s8.west);
\draw[arrow] (s8.south) -- ++(0,-0.5cm) -| ([xshift=0.4cm]s9.east) -- (s9.east);
\draw[arrow] (cond.south) -- node[left, font=\scriptsize] {No} (s9.north);

\end{tikzpicture}%
}
\caption{Preprocessing pipeline for converting raw environments into binary occupancy grids.}
\label{fig:preprocessing}
\end{figure}


%======================================================================
\section{Fundamental Components}\label{sec:meth_components}
%======================================================================

This section formalises the algorithmic building blocks shared by all three planning pipelines. Each component is defined independently so that it can be referenced by subsequent sections without repetition.

%----------------------------------------------------------------------
\subsection{Grid Representation and State Space}\label{subsec:grid_state}
%----------------------------------------------------------------------

The environment was modelled as an edge-weighted grid graph $G = (V, E, w)$:

\begin{itemize}
\item $V = \{v_{x,y} : 0 \leq x < H,\; 0 \leq y < W\}$ was the vertex set, where $H$ and $W$ denoted the number of rows and columns, respectively.
\item $E \subseteq V \times V$ was the edge set, containing edges between each vertex and its valid neighbours under the chosen connectivity model.
\item $w : E \to \mathbb{R}^{+}$ was the edge-weight function.
\end{itemize}

Each vertex carried a binary occupancy label:
\begin{equation}\label{eq:occupancy}
\mathrm{occ}(v) =
\begin{cases}
1 & \text{if } v \text{ is blocked (obstacle)}, \\
0 & \text{otherwise}.
\end{cases}
\end{equation}

The obstacle set was defined as $O = \{v \in V : \mathrm{occ}(v) = 1\}$. A vertex $v$ was considered traversable if and only if $\mathrm{occ}(v) = 0$.

%----------------------------------------------------------------------
\subsection{Movement Model and Edge Costs}\label{subsec:movement}
%----------------------------------------------------------------------

Two connectivity models were employed across the experiments:

\textbf{8-Connected Grid (DS1--DS3).} Each non-boundary vertex had up to eight neighbours: four cardinal (horizontal and vertical) and four diagonal. Edge costs were assigned as:
\begin{equation}\label{eq:cost_8conn}
w(v, v') =
\begin{cases}
1 & \text{for cardinal moves}, \\
\sqrt{2} & \text{for diagonal moves}.
\end{cases}
\end{equation}

\textbf{4-Connected Grid (Drone Implementation).} For the drone-based planning pipeline (Chapter~\ref{chap:pipeline}), each non-boundary vertex had up to four cardinal neighbours, and all edge costs were uniform:
\begin{equation}\label{eq:cost_4conn}
w(v, v') = 1 \quad \text{for all cardinal moves}.
\end{equation}

The 4-connected model was adopted for the drone implementation to simplify waypoint generation, as cardinal-only movement translated directly to axis-aligned flight segments.

%----------------------------------------------------------------------
\subsection{Heuristic Functions}\label{subsec:heuristics}
%----------------------------------------------------------------------

Heuristic-guided algorithms (A*, Greedy Best-First Search) required an admissible heuristic function $h : V \to \mathbb{R}_{\geq 0}$ to estimate the cost-to-go from any vertex to the goal.

\textbf{Octile Distance (8-Connected Grids).} For 8-connected grids, the octile distance was used:
\begin{equation}\label{eq:octile}
h_{\mathrm{oct}}(v) = \max(\Delta x, \Delta y) + (\sqrt{2} - 1) \cdot \min(\Delta x, \Delta y),
\end{equation}
where $\Delta x = |v_x - g_x|$ and $\Delta y = |v_y - g_y|$. The octile distance is both admissible and consistent on 8-connected grids with the cost model of Equation~\eqref{eq:cost_8conn} \citep{Hart1968}.

\textbf{Manhattan Distance (4-Connected Grids).} For 4-connected grids, the Manhattan distance was used:
\begin{equation}\label{eq:manhattan}
h_{\mathrm{man}}(v) = |v_x - g_x| + |v_y - g_y|.
\end{equation}

The Manhattan distance is admissible and consistent on 4-connected grids with uniform edge costs \citep{Hart1968}.

%----------------------------------------------------------------------
\subsection{Baseline Search Algorithms}\label{subsec:baselines}
%----------------------------------------------------------------------

Five classical pathfinding algorithms were employed as baseline planners. Each algorithm was implemented in its standard form and subsequently adapted for corridor-constrained search (Sections~\ref{sec:meth_ils_pipeline} and~\ref{sec:meth_ails_pipeline}).

\begin{enumerate}[label=(\roman*)]

\item \textbf{A* Search} \citep{Hart1968}. A best-first search that expanded the vertex with the smallest evaluation function $f(v) = g(v) + h(v)$, where $g(v)$ was the cost-to-come from the start and $h(v)$ the heuristic estimate. A* was guaranteed to return an optimal path when the heuristic was admissible and consistent \citep{Hart1968}.

\item \textbf{Dijkstra's Algorithm} \citep{Dijkstra1959}. Equivalent to A* with $h(v) = 0$ for all $v$. Dijkstra's algorithm performed an uninformed search and guaranteed optimal paths on graphs with non-negative edge weights.

\item \textbf{Breadth-First Search (BFS)} \citep{Cormen2009}. An uninformed search that explored vertices in order of their hop distance from the start. BFS returned optimal paths on unweighted graphs or graphs with uniform edge costs.

\item \textbf{Depth-First Search (DFS)} \citep{Cormen2009}. An uninformed search that explored as deeply as possible along each branch before backtracking. DFS did not guarantee optimal paths and was included to evaluate the effect of corridor-based restriction on inherently non-optimal algorithms.

\item \textbf{Greedy Best-First Search} \citep{Russell2021}. A best-first search that expanded the vertex with the smallest heuristic value $h(v)$, disregarding the cost-to-come $g(v)$. This algorithm was fast but did not guarantee optimal paths.

\end{enumerate}

In the AILS experiments, Bidirectional A* \citep{Russell2021}---which ran two simultaneous A* searches from start and goal, terminating when the search frontiers met---was additionally employed as a baseline.

%----------------------------------------------------------------------
\subsection{Bresenham Line Algorithm}\label{subsec:bresenham}
%----------------------------------------------------------------------

The Bresenham line algorithm \citep{Bresenham1965} was the geometric foundation of both ILS and AILS. Given two integer endpoints $s = (x_s, y_s)$ and $g = (x_g, y_g)$, the algorithm computed a discrete set of grid cells $\mathcal{L}(s, g)$ that best approximated the continuous line segment from $s$ to $g$ using only integer arithmetic. The algorithm stepped along the major axis (the axis with the larger absolute displacement) and incrementally adjusted the minor-axis coordinate to minimise the approximation error.

The resulting cell sequence satisfied $s, g \in \mathcal{L}(s, g)$ and had length $|\mathcal{L}| = \max(|x_g - x_s|, |y_g - y_s|) + 1$. Consecutive cells in $\mathcal{L}$ differed by at most one unit in each coordinate. The algorithm ran in $O(|\mathcal{L}|)$ time.

The Bresenham line served as the central axis of the search corridor in both ILS and AILS. It was not required to be obstacle-free; obstacles along the line were handled by the corridor expansion mechanism described in Sections~\ref{sec:meth_ils_pipeline} and~\ref{sec:meth_ails_pipeline}.

%----------------------------------------------------------------------
\subsection{ILS Corridor Construction}\label{subsec:ils_corridor}
%----------------------------------------------------------------------

In the ILS framework, a uniform-width corridor was constructed around the Bresenham reference line. The corridor was defined as the set of all grid cells within a specified distance of any cell on the reference line.

\begin{definition}[ILS Corridor Region]\label{def:ils_corridor}
Given a grid $G$ of dimensions $H \times W$, start cell $s$, goal cell $g$, and width parameter $w_0$ expressed as a fraction of the smaller grid dimension, the \emph{ILS corridor} $\mathcal{C}(s, g, w_0)$ was the set of all traversable grid cells within distance $w_0$ of any cell on the Bresenham line $\mathcal{L}(s, g)$:
\[
\mathcal{C}(s, g, w_0) = \bigl\{ v \in V \setminus O \;\big|\; \exists\, p \in \mathcal{L}(s, g) : d(v, p) \leq w_0 \bigr\},
\]
where $d(\cdot, \cdot)$ denoted the distance metric appropriate to the connectivity model (Chebyshev distance for 8-connected grids, Manhattan distance for 4-connected grids).
\end{definition}

The initial corridor width was set proportionally to the smaller grid dimension: $w_0 = \lfloor \gamma \cdot \min(H, W) \rfloor$, where $\gamma$ was a configurable parameter (see Table~\ref{tab:ils_params} in Section~\ref{sec:meth_ils_pipeline}). If no valid path was found within the initial corridor, the width was expanded by a fixed increment $\Delta w$ and the search was repeated. This incremental expansion continued until a path was found or the corridor width reached the maximum allowable value $w_{\max} = \min(H, W)$, at which point the corridor encompassed the entire grid.

%----------------------------------------------------------------------
\subsection{AILS Adaptive Corridor Construction}\label{subsec:ails_corridor}
%----------------------------------------------------------------------

The Adaptive ILS (AILS) framework extended the uniform-width corridor of ILS by computing a per-point corridor radius based on the local obstacle density. This section describes the three key mechanisms: density estimation, adaptive radius computation, and corridor cell-set construction.

\textbf{Local Density Estimation.} For each reference-line cell $p \in \mathcal{L}$, the local obstacle density was computed within a square window of half-size $\omega$ (full side length $2\omega + 1$) centred at $p$:
\begin{equation}\label{eq:density_window}
\mathcal{W}(p) = \{v_{x,y} \in V : |x - p_x| \leq \omega,\; |y - p_y| \leq \omega\},
\end{equation}
\begin{equation}\label{eq:density}
\sigma(p) = \frac{|O \cap \mathcal{W}(p)|}{|\mathcal{W}(p)|} \in [0, 1].
\end{equation}

A value of $\sigma(p) = 0$ indicated an obstacle-free window; $\sigma(p) = 1$ indicated a fully blocked window. Each density query was computed in $O(1)$ time using the precomputed integral image (summed-area table) described in Section~\ref{subsec:preprocessing}:
\begin{equation}\label{eq:integral_query}
\sigma(p) = \frac{I(x{+}\omega,\; y{+}\omega) - I(x{-}\omega{-}1,\; y{+}\omega) - I(x{+}\omega,\; y{-}\omega{-}1) + I(x{-}\omega{-}1,\; y{-}\omega{-}1)}{(2\omega + 1)^2},
\end{equation}
where boundary cases (windows extending outside the grid) were handled by index clamping.

\textbf{Per-Point Radius Computation.} The corridor radius at each reference-line cell was computed as:
\begin{equation}\label{eq:radius_standard}
r(p) = r_{\min} + \bigl\lfloor (r_{\max} - r_{\min}) \cdot \sigma(p)^{\alpha} \bigr\rfloor,
\end{equation}
where the parameters had the following roles:
\begin{itemize}
\item $r_{\min} \geq 1$: minimum radius, applied in obstacle-free regions (default: 2 cells);
\item $r_{\max}$: maximum radius, applied when the window was fully blocked (default: $\lceil 0.1 \cdot \min(H, W) \rceil$);
\item $\alpha > 0$: density-sensitivity exponent (default: 1.0). Values $\alpha < 1$ widened the corridor at low densities; values $\alpha > 1$ kept it narrow until density was high.
\end{itemize}

When $\sigma(p) = 0$, $r(p) = r_{\min}$ (narrowest band). When $\sigma(p) = 1$, $r(p) = r_{\max}$ (widest band). This mapping produced a non-convex, variable-width corridor that was narrow in open regions and widened only where obstacles were present.

\textbf{Gradient-Enhanced Radius (Predictive Strategy).} When gradient-based lookahead was enabled, the radius incorporated the density gradient magnitude:
\begin{equation}\label{eq:radius_gradient}
r(p) = r_{\min} + \bigl\lfloor (r_{\max} - r_{\min}) \cdot \bigl(\sigma(p) + \beta \,|\nabla \sigma(p)|\bigr)^{\alpha} \bigr\rfloor,
\end{equation}
where $\beta \geq 0$ controlled gradient sensitivity (default: 0.3), and the argument was clamped to $[0, 1]$ before exponentiation. The density gradient was computed via finite differences:
\begin{equation}\label{eq:gradient}
\nabla \sigma(p) = \left( \frac{\sigma(p_x{+}1, p_y) - \sigma(p_x{-}1, p_y)}{2},\; \frac{\sigma(p_x, p_y{+}1) - \sigma(p_x, p_y{-}1)}{2} \right).
\end{equation}

This allowed the corridor to widen \emph{before} the search reached a dense region, reducing the likelihood of a failed constrained search.

\textbf{Corridor Cell Set.} The AILS corridor was the union of Chebyshev balls centred at each reference-line cell:
\begin{equation}\label{eq:ails_corridor}
\mathcal{C}_a = \bigcup_{p \in \mathcal{L}} B(p, r(p)), \quad B(p, r) = \{v \in V : \max(|v_x - p_x|, |v_y - p_y|) \leq r\}.
\end{equation}

Only traversable cells ($\mathrm{occ}(v) = 0$) within grid bounds were included in $\mathcal{C}_a$. The corridor was stored as a hash set for $O(1)$ membership queries during the constrained search.

%----------------------------------------------------------------------
\subsection{Path Reconstruction and Post-Processing}\label{subsec:reconstruction}
%----------------------------------------------------------------------

Upon termination of any search algorithm, the solution path was reconstructed by following parent pointers from the goal vertex back to the start vertex. The resulting path $\pi = (v_0, v_1, \ldots, v_k)$ with $v_0 = s$ and $v_k = g$ was a sequence of adjacent vertices.

For A* and Dijkstra integrated with ILS, a line-of-sight post-processing step was applied to the recovered path. This step followed the principle of Theta* \citep{Nash2007}: if a vertex's grandparent had a clear line of sight to the current vertex (verified via Bresenham's algorithm), the intermediate parent was removed, producing a shorter, smoother path. This any-angle smoothing was applied as a post-processing step rather than during the search, thereby preserving the optimality guarantees of the underlying algorithm within the corridor.

For BFS integrated with ILS, a similar line-of-sight simplification was applied after path recovery: unnecessary intermediate waypoints were removed wherever a direct line of sight existed between non-adjacent path vertices.

DFS and Greedy Best-First Search did not receive line-of-sight post-processing, as these algorithms did not guarantee optimal paths and the post-processing was designed to improve geometric quality rather than to compensate for algorithmic suboptimality.


%======================================================================
\section{Adaptive Corridor and Strategy Selection Procedure}\label{sec:meth_adaptive}
%======================================================================

This section describes the strategy-selection mechanism that determined which corridor construction method was applied for a given query, as well as the fallback expansion procedure that ensured completeness.

%----------------------------------------------------------------------
\subsection{Multi-Strategy Selection}\label{subsec:strategy_selection}
%----------------------------------------------------------------------

AILS provided three corridor strategies, selected automatically by a lightweight scan of the Bresenham reference line at initialisation:

\begin{enumerate}[label=\textbf{Strategy~\arabic*:}]

\item \textbf{Base (Fixed-Width).} If $\sigma(p) = 0$ for every $p \in \mathcal{L}$ (i.e., the Bresenham line was obstacle-free), a fixed corridor of radius $r_{\min}$ was used. This strategy avoided the per-point density computation entirely and was computationally the cheapest option.

\item \textbf{Standard (Density-Adaptive).} If obstacles were detected along $\mathcal{L}$ but the density gradient was small ($\max_{p \in \mathcal{L}} |\nabla \sigma(p)| < 0.1$), the per-point radius was computed using Equation~\eqref{eq:radius_standard}. This was the default strategy and covered the majority of scenarios.

\item \textbf{Predictive (Gradient-Enhanced).} If the density changed rapidly along $\mathcal{L}$ ($\max_{p \in \mathcal{L}} |\nabla \sigma(p)| \geq 0.1$), the gradient-enhanced radius of Equation~\eqref{eq:radius_gradient} was used, widening the corridor before dense regions were reached.

\end{enumerate}

The threshold $|\nabla \sigma| = 0.1$ was a tunable hyperparameter. The default value was adopted from the AILS study and was found to perform well across all tested obstacle patterns \citep{Elshahed2025AILS}.

Figure~\ref{fig:strategy_flowchart} illustrates the strategy-selection logic.

\begin{figure}[htb!]
\centering
\resizebox{0.92\textwidth}{!}{%
\begin{tikzpicture}[
    >=Stealth,
    node distance=0.8cm,
    startend/.style={rectangle, draw, thick, fill=gray!10, minimum width=4.5cm, minimum height=0.75cm,
                     rounded corners=10pt, font=\small\bfseries, align=center},
    procbox/.style={rectangle, draw, thick, fill=blue!6, minimum width=4.5cm, minimum height=0.75cm,
                    rounded corners=3pt, font=\small, align=center},
    decision/.style={diamond, draw, thick, fill=yellow!10, aspect=2.8, font=\small, align=center,
                     inner sep=2pt},
    stratbox/.style={rectangle, draw, thick, fill=#1, minimum width=5.5cm, minimum height=1.5cm,
                     rounded corners=4pt, font=\small, align=center, inner sep=6pt},
    arrow/.style={->, thick, >=Stealth},
]

% --- Start ---
\node[startend] (start) {Input: Bresenham line $\mathcal{L}(s, g)$};

% --- Scan ---
\node[procbox, below=0.7cm of start] (scan) {Compute $\sigma(p)$ and $\nabla\sigma(p)$ for all $p \in \mathcal{L}$};

% --- Decision 1 ---
\node[decision, below=0.9cm of scan] (d1) {$\sigma(p) = 0$\\for all $p \in \mathcal{L}$?};

% --- Base Strategy (right of d1) ---
\node[stratbox=green!10, right=3.2cm of d1] (base) {\textbf{Strategy 1: Base}\\[2pt]\scriptsize Fixed-width corridor, radius $r_{\min}$\\[1pt]\scriptsize No per-point density computation};

% --- Decision 2 ---
\node[decision, below=1.4cm of d1] (d2) {$\max_{p} |\nabla\sigma(p)|$\\$< 0.1$?};

% --- Standard Strategy (right of d2) ---
\node[stratbox=cyan!10, right=3.2cm of d2] (standard) {\textbf{Strategy 2: Standard}\\[2pt]\scriptsize Density-adaptive radius\\[1pt]\scriptsize $r(p) = r_{\min} + \lfloor (r_{\max} - r_{\min}) \cdot \sigma(p)^{\alpha} \rfloor$};

% --- Predictive Strategy ---
\node[stratbox=violet!10, below=1.4cm of d2] (predictive) {\textbf{Strategy 3: Predictive}\\[2pt]\scriptsize Gradient-enhanced radius\\[1pt]\scriptsize $r(p) = r_{\min} + \lfloor (r_{\max} - r_{\min}) \cdot (\sigma(p) + \beta\,|\nabla\sigma(p)|)^{\alpha} \rfloor$};

% --- Build Corridor ---
\node[procbox, fill=orange!8, below=1.2cm of predictive] (build) {Build adaptive corridor $\mathcal{C}_a$ using selected strategy};

% --- End ---
\node[startend, below=0.7cm of build] (endnode) {Proceed to constrained search};

% --- Arrows ---
\draw[arrow] (start) -- (scan);
\draw[arrow] (scan) -- (d1);

% Decision 1: Yes -> Base
\draw[arrow] (d1.east) -- node[above, font=\scriptsize] {Yes} (base.west);

% Decision 1: No -> Decision 2
\draw[arrow] (d1.south) -- node[left, font=\scriptsize] {No} (d2.north);

% Decision 2: Yes -> Standard
\draw[arrow] (d2.east) -- node[above, font=\scriptsize] {Yes} (standard.west);

% Decision 2: No -> Predictive
\draw[arrow] (d2.south) -- node[left, font=\scriptsize] {No} (predictive.north);

% Strategies to Build Corridor --- route via right-side rail to avoid crossing boxes
\draw[arrow] (base.east) -- ++(0.8cm,0) |- ([yshift=0.15cm]build.east);
\draw[arrow] (standard.east) -- ++(0.4cm,0) |- ([yshift=-0.15cm]build.east);
\draw[arrow] (predictive.south) -- (build.north);

% Build to End
\draw[arrow] (build) -- (endnode);

\end{tikzpicture}%
}
\caption{Flowchart of the AILS multi-strategy selection procedure. The strategy was determined by scanning obstacle density and its gradient along the Bresenham reference line.}
\label{fig:strategy_flowchart}
\end{figure}

%----------------------------------------------------------------------
\subsection{Fallback Expansion Procedure}\label{subsec:fallback}
%----------------------------------------------------------------------

If the constrained search (whether ILS or AILS) failed to find a path within the current corridor---i.e., the open list was exhausted without reaching the goal---the corridor was expanded and the search was repeated.

\textbf{ILS Fallback.} In the ILS framework, the corridor was expanded globally: the width parameter was incremented by a fixed step $\Delta w$, and the entire corridor was rebuilt at the new width. This process was repeated until a path was found or the corridor width reached $w_{\max}$.

\textbf{AILS Fallback.} In the AILS framework, the corridor was expanded locally via a breadth-first traversal from the current corridor boundary. All traversable cells within Chebyshev distance $\Delta r$ of the boundary were added to the corridor:
\begin{equation}\label{eq:ails_expansion}
\mathcal{C}_a' = \mathcal{C}_a \cup \{v \in V \setminus \mathcal{C}_a : \mathrm{occ}(v) = 0,\; \exists\, u \in \mathcal{C}_a \text{ with } \|v - u\|_{\infty} \leq \Delta r\}.
\end{equation}

The constrained search was then re-executed on the enlarged corridor. The process was repeated until a path was found or $\mathcal{C}_a = V$ (the full grid had been explored). This local expansion was more efficient than the global expansion of ILS, as it added cells only at the corridor boundary rather than rebuilding the entire corridor.

%----------------------------------------------------------------------
\subsection{Algorithm Pseudocode}\label{subsec:ails_pseudocode}
%----------------------------------------------------------------------

Algorithm~\ref{alg:build_corridor} presents the pseudocode for the adaptive corridor construction procedure, and Algorithm~\ref{alg:ails_main} presents the complete AILS-enhanced pathfinding procedure with fallback expansion.

\begin{algorithm}[htb!]
\caption{BuildAdaptiveCorridor}\label{alg:build_corridor}
\begin{algorithmic}[1]
\Require Grid $G = (V, E, w)$; Bresenham line $\mathcal{L}$; integral image $I$; parameters $r_{\min}$, $r_{\max}$, $\alpha$, $\omega$
\Ensure Corridor set $\mathcal{C}_a \subseteq V$ (traversable cells only)
\Statex
\State $\mathcal{C}_a \gets \emptyset$
\For{$i = 0$ \textbf{to} $|\mathcal{L}| - 1$}
  \State $p \gets \mathcal{L}[i]$
  \State $\sigma(p) \gets \textsc{DensityQuery}(I, p, \omega)$ \Comment{$O(1)$ via integral image}
  \State $r(p) \gets r_{\min} + \lfloor (r_{\max} - r_{\min}) \cdot \sigma(p)^{\alpha} \rfloor$
  \For{$\Delta x = -r(p)$ \textbf{to} $r(p)$}
    \For{$\Delta y = -r(p)$ \textbf{to} $r(p)$}
      \State $v \gets (p_x + \Delta x,\; p_y + \Delta y)$
      \If{$v$ is within grid bounds \textbf{and} $\mathrm{occ}(v) = 0$}
        \State $\mathcal{C}_a \gets \mathcal{C}_a \cup \{v\}$
      \EndIf
    \EndFor
  \EndFor
\EndFor
\State \Return $\mathcal{C}_a$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[htb!]
\caption{AILS-Enhanced Pathfinding}\label{alg:ails_main}
\begin{algorithmic}[1]
\Require Grid $G = (V, E, w)$; start $s$; goal $g$; base algorithm $\mathcal{A}$; parameters $r_{\min}$, $r_{\max}$, $\alpha$, $\omega$, $\Delta r$
\Ensure Path $\pi$ within corridor, or $\emptyset$ if no $s$--$g$ path exists in $G$
\Statex
\State $I \gets \textsc{BuildIntegralImage}(G)$ \Comment{$O(|V|)$ preprocessing}
\State $\mathcal{L} \gets \textsc{BresenhamLine}(s, g)$ \Comment{Reference line, $O(|\mathcal{L}|)$}
\State $\mathcal{C}_a \gets \textsc{BuildAdaptiveCorridor}(G, \mathcal{L}, I, r_{\min}, r_{\max}, \alpha, \omega)$
\Repeat
  \State $\pi \gets \mathcal{A}.\textsc{Search}(G, s, g, \mathcal{C}_a)$ \Comment{Constrained search}
  \If{$\pi \neq \emptyset$}
    \State \Return $\pi$
  \EndIf
  \If{$\mathcal{C}_a = V$}
    \State \Return $\emptyset$ \Comment{Full grid explored; no path exists}
  \EndIf
  \State $\mathcal{C}_a \gets \textsc{ExpandCorridor}(\mathcal{C}_a, \Delta r)$ \Comment{BFS boundary expansion}
\Until{false}
\end{algorithmic}
\end{algorithm}


%======================================================================
\section{ILS-Enhanced Planning Pipeline}\label{sec:meth_ils_pipeline}
%======================================================================

This section describes the ILS-enhanced planning pipeline (Pipeline~2), which integrated the Incremental Line Search optimisation with the five classical algorithms described in Section~\ref{subsec:baselines}.

%----------------------------------------------------------------------
\subsection{Objective}\label{subsec:ils_objective}
%----------------------------------------------------------------------

The objective of the ILS pipeline was to evaluate the effect of corridor-based search-space restriction on the performance of classical pathfinding algorithms. The pipeline constrained each algorithm's neighbour expansion to the ILS corridor and measured the resulting changes in execution time, visited nodes, and path length relative to the unconstrained baselines.

%----------------------------------------------------------------------
\subsection{Algorithm-Specific Adaptations}\label{subsec:ils_adaptations}
%----------------------------------------------------------------------

Each classical algorithm was adapted to the ILS framework as follows:

\textbf{A* + ILS.} The standard A* algorithm was modified to restrict neighbour expansion to the corridor. Additionally, line-of-sight checks were incorporated during path reconstruction: if a vertex's grandparent had a clear line of sight to the current vertex (verified via Bresenham's line algorithm), the intermediate parent was bypassed. This adaptation followed the principle of Theta* \citep{Nash2007} and was applied to produce smoother paths.

\textbf{Dijkstra + ILS.} As Dijkstra's algorithm is equivalent to A* with $h(v) = 0$, the same corridor restriction and line-of-sight logic were applied.

\textbf{BFS + ILS.} BFS was constrained to explore only within the corridor. After the standard BFS path was found, a line-of-sight simplification was performed as a post-processing step to remove unnecessary intermediate waypoints.

\textbf{DFS + ILS.} DFS was constrained to the corridor, limiting its depth-first traversal to the defined search region. No line-of-sight post-processing was applied.

\textbf{Best-First Search + ILS.} The heuristic-guided expansion was limited to vertices inside the corridor. No line-of-sight post-processing was applied.

In all cases, vertices outside the corridor were excluded from consideration during neighbour expansion. This design ensured a fair and consistent application of ILS across algorithms.

%----------------------------------------------------------------------
\subsection{ILS Procedure}\label{subsec:ils_procedure}
%----------------------------------------------------------------------

The ILS procedure operated as follows:

\begin{enumerate}[label=\textbf{Step~\arabic*:}]
\item Compute the Bresenham reference line $\mathcal{L}(s, g)$ from start to goal.
\item Construct the initial corridor of width $w_0$ around $\mathcal{L}$.
\item Execute the chosen pathfinding algorithm, restricting neighbour expansion to corridor cells.
\item If a valid path was found, return it (with line-of-sight post-processing where applicable).
\item If no path was found, expand the corridor width by $\Delta w$ and repeat from Step~3.
\item If the corridor width exceeded $w_{\max}$, terminate and report failure.
\end{enumerate}

Algorithm~\ref{alg:ils} presents the pseudocode.

\begin{algorithm}[htb!]
\caption{Incremental Line Search (ILS)}\label{alg:ils}
\begin{algorithmic}[1]
\Require Graph $G = (V, E)$; start $s$; goal $g$; algorithm $\mathcal{A}$; initial width $w_0$; max width $w_{\max}$; step size $\Delta w$
\Ensure Path $\pi$ or Failure
\Statex
\State $\mathcal{L} \gets \textsc{BresenhamLine}(s, g)$
\State $w \gets w_0$
\State Define corridor $\mathcal{C}$ of width $w$ around $\mathcal{L}$
\While{\textbf{true}}
  \State $\pi \gets \mathcal{A}.\textsc{Search}(G, s, g, \mathcal{C})$ \Comment{Restricted to corridor}
  \If{$\pi \neq \emptyset$}
    \State \Return $\pi$
  \Else
    \State $w \gets w + \Delta w$
    \State Update corridor $\mathcal{C}$ to width $w$
  \EndIf
  \If{$w > w_{\max}$}
    \State \Return Failure
  \EndIf
\EndWhile
\end{algorithmic}
\end{algorithm}

%----------------------------------------------------------------------
\subsection{ILS Parameters}\label{subsec:ils_params}
%----------------------------------------------------------------------

Table~\ref{tab:ils_params} summarises the ILS corridor parameters used in the experiments.

\begin{table}[htb!]
\centering
\caption{ILS Corridor Parameters}
\label{tab:ils_params}
\begin{tabular}{|l|l|p{6cm}|}
\hline
\textbf{Parameter} & \textbf{Value} & \textbf{Description} \\
\hline
$w_0$ & $\lfloor \gamma \cdot \min(H, W) \rfloor$ & Initial corridor width, where $\gamma$ was a configurable fraction of the smaller grid dimension \\
\hline
$\Delta w$ & Fixed increment & Step size for corridor expansion upon search failure \\
\hline
$w_{\max}$ & $\min(H, W)$ & Maximum corridor width, equal to the smaller grid dimension (ensuring full-grid coverage if reached) \\
\hline
Connectivity & 8-connected & Neighbourhood model used for DS1--DS3 \\
\hline
Distance metric & Chebyshev & Distance metric for corridor membership on 8-connected grids \\
\hline
\end{tabular}
\end{table}

The initial corridor width was deliberately set as a fraction of the grid dimension rather than as a fixed absolute value. This proportional sizing ensured that the corridor scaled appropriately with grid size, maintaining a consistent ratio of corridor area to total grid area across different map dimensions.


%======================================================================
\section{Baseline Planner Pipeline}\label{sec:meth_baseline_pipeline}
%======================================================================

This section describes the baseline planner pipeline (Pipeline~1), which provided the reference performance measurements against which the corridor-based methods were evaluated.

%----------------------------------------------------------------------
\subsection{Objective}\label{subsec:baseline_objective}
%----------------------------------------------------------------------

The objective of the baseline pipeline was to execute each classical pathfinding algorithm on the full grid without any search-space restriction, thereby establishing the unconstrained performance envelope for each algorithm across all datasets.

%----------------------------------------------------------------------
\subsection{Specification}\label{subsec:baseline_spec}
%----------------------------------------------------------------------

The baseline pipeline proceeded as follows for each algorithm-dataset combination:

\begin{enumerate}[label=\textbf{Step~\arabic*:}]
\item Load the preprocessed grid and start/goal positions.
\item Execute the chosen algorithm ($\mathcal{A} \in \{\text{A*}, \text{Dijkstra}, \text{BFS}, \text{DFS}, \text{Best-First}\}$) on the full grid $G$.
\item Record the execution time (wall-clock), the number of visited nodes (vertices expanded), and the path length (total edge cost of the recovered path).
\item Repeat for all maps in the dataset.
\end{enumerate}

No corridor restriction, line-of-sight post-processing, or other optimisation was applied. The algorithms were implemented identically to those used in the ILS and AILS pipelines, with the sole difference that the neighbour-expansion function was not filtered by corridor membership.

%----------------------------------------------------------------------
\subsection{Baseline Pseudocode}\label{subsec:baseline_pseudocode}
%----------------------------------------------------------------------

For completeness, Algorithm~\ref{alg:baseline} presents the generic baseline search procedure.

\begin{algorithm}[htb!]
\caption{Baseline Planner (Unconstrained Search)}\label{alg:baseline}
\begin{algorithmic}[1]
\Require Graph $G = (V, E, w)$; start $s$; goal $g$; algorithm $\mathcal{A}$
\Ensure Path $\pi$ or Failure
\Statex
\State Initialise $\mathcal{A}$ with start vertex $s$
\While{$\mathcal{A}$ has vertices to expand}
  \State $v \gets$ next vertex selected by $\mathcal{A}$
  \If{$v = g$}
    \State \Return \textsc{ReconstructPath}($v$)
  \EndIf
  \ForAll{neighbours $u$ of $v$ in $G$ with $\mathrm{occ}(u) = 0$}
    \State Process $u$ according to $\mathcal{A}$'s update rule
  \EndFor
\EndWhile
\State \Return Failure
\end{algorithmic}
\end{algorithm}


%======================================================================
\section{Adaptive ILS Planning Pipeline}\label{sec:meth_ails_pipeline}
%======================================================================

This section describes the Adaptive ILS planning pipeline (Pipeline~3), which extended the ILS approach with per-point density-based corridor construction.

%----------------------------------------------------------------------
\subsection{Objective}\label{subsec:ails_objective}
%----------------------------------------------------------------------

The objective of the AILS pipeline was to evaluate whether a variable-width corridor, whose radius at each reference-line cell was adapted to the local obstacle density, could provide robust search-space reduction across diverse obstacle topologies---including environments where a uniform-width corridor would either over-expand in open regions or under-expand near obstacles.

%----------------------------------------------------------------------
\subsection{Architecture}\label{subsec:ails_architecture}
%----------------------------------------------------------------------

The AILS pipeline comprised four stages, executed sequentially for each query:

\begin{enumerate}[label=\textbf{Stage~\arabic*:}]
\item \textbf{Reference-Line Generation.} The Bresenham line $\mathcal{L}(s, g)$ was computed from start to goal (Section~\ref{subsec:bresenham}).
\item \textbf{Per-Point Density Estimation.} For each cell $p \in \mathcal{L}$, the local obstacle density $\sigma(p)$ was computed via an $O(1)$ integral-image query (Section~\ref{subsec:ails_corridor}).
\item \textbf{Adaptive Corridor Construction.} The per-point radius $r(p)$ was computed and the corridor cell set $\mathcal{C}_a$ was assembled (Section~\ref{subsec:ails_corridor}).
\item \textbf{Corridor-Constrained Search with Fallback.} The base search algorithm was executed within $\mathcal{C}_a$, with local BFS expansion as fallback if no path was found (Section~\ref{subsec:fallback}).
\end{enumerate}

The strategy-selection procedure (Section~\ref{subsec:strategy_selection}) determined which radius formula was applied at Stage~3.

Figure~\ref{fig:ails_architecture} illustrates the four-stage architecture.

\begin{figure}[htb!]
\centering
\resizebox{0.95\textwidth}{!}{%
\begin{tikzpicture}[
    >=Stealth,
    node distance=0.5cm and 0.7cm,
    inputbox/.style={rectangle, draw, thick, fill=gray!10, minimum width=2.8cm, minimum height=0.9cm,
                     rounded corners=10pt, font=\small\bfseries, align=center},
    stagebox/.style={rectangle, draw, thick, fill=#1, minimum width=3.2cm, minimum height=2.0cm,
                     rounded corners=4pt, align=center},
    stagetitle/.style={font=\small\bfseries, align=center},
    stagedesc/.style={font=\scriptsize, align=center, text width=2.8cm},
    decision/.style={diamond, draw, thick, fill=yellow!10, aspect=2.2, font=\small, align=center,
                     inner sep=2pt},
    outputbox/.style={rectangle, draw, thick, fill=green!10, minimum width=2.8cm, minimum height=0.9cm,
                      rounded corners=10pt, font=\small\bfseries, align=center},
    failbox/.style={rectangle, draw, thick, fill=red!8, minimum width=2.2cm, minimum height=0.7cm,
                    rounded corners=3pt, font=\small, align=center},
    arrow/.style={->, thick, >=Stealth},
    darrow/.style={->, thick, >=Stealth, dashed, red!60!black},
]

% --- Input ---
\node[inputbox] (input) {Input\\[-1pt]\scriptsize Grid $G$, start $s$, goal $g$};

% --- Stage 1 ---
\node[stagebox=blue!8, right=1.0cm of input] (s1) {};
\node[stagetitle, anchor=north] at ([yshift=-0.15cm]s1.north) {Stage 1};
\node[stagedesc, anchor=north] at ([yshift=-0.5cm]s1.north) {Reference-Line\\Generation\\[3pt]\scriptsize Bresenham line\\$\mathcal{L}(s, g)$};

% --- Stage 2 ---
\node[stagebox=cyan!8, right=0.7cm of s1] (s2) {};
\node[stagetitle, anchor=north] at ([yshift=-0.15cm]s2.north) {Stage 2};
\node[stagedesc, anchor=north] at ([yshift=-0.5cm]s2.north) {Density\\Estimation\\[3pt]\scriptsize $\sigma(p)$ via $O(1)$\\integral image};

% --- Stage 3 ---
\node[stagebox=violet!8, right=0.7cm of s2] (s3) {};
\node[stagetitle, anchor=north] at ([yshift=-0.15cm]s3.north) {Stage 3};
\node[stagedesc, anchor=north] at ([yshift=-0.5cm]s3.north) {Adaptive Corridor\\Construction\\[3pt]\scriptsize Per-point $r(p)$\\$\to \mathcal{C}_a$};

% --- Stage 4 ---
\node[stagebox=orange!8, right=0.7cm of s3] (s4) {};
\node[stagetitle, anchor=north] at ([yshift=-0.15cm]s4.north) {Stage 4};
\node[stagedesc, anchor=north] at ([yshift=-0.5cm]s4.north) {Constrained\\Search\\[3pt]\scriptsize Algorithm $\mathcal{A}$\\within $\mathcal{C}_a$};

% --- Decision: Path found? ---
\node[decision, right=1.0cm of s4] (dec) {Path\\found?};

% --- Output ---
\node[outputbox, above right=0.4cm and 1.2cm of dec] (output) {Output\\[-1pt]\scriptsize Path $\pi$};

% --- Fallback ---
\node[failbox, below right=0.4cm and 1.2cm of dec] (fallback) {Fallback:\\[-1pt]\scriptsize BFS Expansion\\$\mathcal{C}_a \gets \mathcal{C}_a'$};

% --- Arrows: main flow ---
\draw[arrow] (input) -- (s1);
\draw[arrow] (s1) -- (s2);
\draw[arrow] (s2) -- (s3);
\draw[arrow] (s3) -- (s4);
\draw[arrow] (s4) -- (dec);

% --- Decision arrows ---
\draw[arrow] (dec.north) |- node[pos=0.3, right, font=\scriptsize] {Yes} (output.west);
\draw[arrow] (dec.south) |- node[pos=0.3, right, font=\scriptsize] {No} (fallback.west);

% --- Fallback loop (dashed) back to Stage 4 ---
\draw[darrow] (fallback.south) -- ++(0,-0.6cm) -| node[pos=0.25, below, font=\scriptsize\itshape, text=red!60!black] {Expand corridor, retry search} (s4.south);

% --- Full grid check ---
\node[failbox, fill=gray!15, right=1.0cm of fallback] (nopath) {No path in $G$};
\draw[arrow] (fallback.east) -- node[above, font=\scriptsize] {$\mathcal{C}_a = V$} (nopath.west);

% --- Strategy selection annotation ---
\node[font=\scriptsize\itshape, text=violet!70!black, anchor=north] at ([yshift=-0.15cm]s3.south) {Strategy selection};
\node[font=\scriptsize\itshape, text=violet!70!black, anchor=north] at ([yshift=-0.45cm]s3.south) {(Base / Standard / Predictive)};

\end{tikzpicture}%
}
\caption{Architecture of the AILS planning pipeline. The four stages are executed sequentially; the fallback loop (dashed arrow) is invoked only when the initial constrained search fails.}
\label{fig:ails_architecture}
\end{figure}

%----------------------------------------------------------------------
\subsection{Constrained Search Procedure}\label{subsec:ails_search}
%----------------------------------------------------------------------

Any graph-search algorithm $\mathcal{A}$ (A*, Dijkstra, BFS) was executed on $G$ with a single modification: the neighbour-expansion function was filtered by corridor membership and occupancy. For each vertex $v$ being expanded, the constrained neighbour set was:
\begin{equation}\label{eq:constrained_neighbors}
\mathrm{neighbors}_{\mathcal{C}}(v) = \{u \in \mathrm{neighbors}(v) : \mathrm{occ}(u) = 0 \;\wedge\; u \in \mathcal{C}_a\}.
\end{equation}

No other part of the base algorithm was modified. Within the corridor, the base algorithm retained its original guarantees: if $\mathcal{A}$ was optimal on the full grid, it returned the shortest path that lay entirely within $\mathcal{C}_a$.

%----------------------------------------------------------------------
\subsection{AILS Parameter Configuration}\label{subsec:ails_params}
%----------------------------------------------------------------------

Table~\ref{tab:ails_params} summarises the default AILS parameters used in the experiments.

\begin{table}[htb!]
\centering
\caption{AILS Default Parameters}
\label{tab:ails_params}
\begin{tabular}{|l|l|p{7cm}|}
\hline
\textbf{Parameter} & \textbf{Default} & \textbf{Description} \\
\hline
$r_{\min}$ & 2 & Minimum corridor radius (cells); applied in obstacle-free regions \\
\hline
$r_{\max}$ & $\lceil 0.1 \cdot \min(H, W) \rceil$ & Maximum corridor radius; applied when the density window was fully blocked \\
\hline
$\alpha$ & 1.0 & Density-sensitivity exponent controlling the rate of radius increase with density \\
\hline
$\omega$ & 3 & Density-estimation window half-size (full side $2\omega + 1 = 7$) \\
\hline
$\beta$ & 0.3 & Gradient sensitivity (Predictive strategy only) \\
\hline
$\Delta r$ & 2 & Chebyshev distance increment for fallback corridor expansion \\
\hline
$|\nabla \sigma|$ threshold & 0.1 & Gradient threshold for strategy selection (Base/Standard vs.\ Predictive) \\
\hline
\end{tabular}
\end{table}

These defaults were adopted from the AILS study \citep{Elshahed2025AILS}. In the AILS experiments, parameter sensitivity was assessed by systematically varying $r_{\min}$, $r_{\max}$, $\alpha$, and $\omega$ while holding other parameters at their defaults (see Chapter~\ref{chap:results}).


%======================================================================
\section{Evaluation Metrics and Experimental Protocol}\label{sec:meth_metrics}
%======================================================================

This section defines the evaluation metrics and the experimental protocol applied uniformly across all three planning pipelines.

%----------------------------------------------------------------------
\subsection{Evaluation Metrics}\label{subsec:metrics}
%----------------------------------------------------------------------

The following metrics were employed to assess algorithm performance:

\begin{enumerate}[label=(\roman*)]

\item \textbf{Execution Time (ms).} The wall-clock time required to compute the path, measured in milliseconds. For the AILS pipeline, execution time included integral-image preprocessing, corridor construction, and the constrained search. For the ILS pipeline, it included Bresenham line computation, corridor construction, and the search. The median of three runs per instance was used to reduce timing variance.

\item \textbf{Visited Nodes.} The total number of vertices expanded (popped from the open list or equivalent data structure) during the search. This metric was independent of hardware and measured the algorithmic efficiency of the search strategy.

\item \textbf{Path Length.} The total edge cost of the recovered path, computed as $\sum_{i=0}^{k-1} w(v_i, v_{i+1})$. For algorithms with line-of-sight post-processing (A*+ILS, Dijkstra+ILS), the post-processed path length was reported.

\item \textbf{Path Length Improvement (\%).} The percentage reduction in path length achieved by the corridor-based variant relative to the standard algorithm:
\begin{equation}\label{eq:improvement}
\text{Improvement} = \frac{\text{Metric}_{\text{Standard}} - \text{Metric}_{\text{ILS/AILS}}}{\text{Metric}_{\text{Standard}}} \times 100.
\end{equation}

\item \textbf{Optimality Rate (\%).} The fraction of instances in which the corridor-based algorithm returned a path whose cost was equal to the globally optimal path cost (as computed by unconstrained A*). This metric applied to the AILS pipeline.

\item \textbf{Corridor Efficiency.} The ratio $|\mathcal{C}_a| / |V|$, measuring the fraction of the total grid enclosed by the corridor. A smaller ratio indicated greater search-space reduction.

\item \textbf{Success Rate (\%).} The fraction of instances for which the algorithm returned a valid path. Instances with no reachable path were excluded from timing metrics but included in the success-rate computation.

\item \textbf{Node Reduction (\%).} The percentage reduction in visited nodes achieved by the corridor-based variant relative to unconstrained A*:
\begin{equation}\label{eq:node_reduction}
\text{Node Reduction} = \frac{\text{Nodes}_{\text{A*}} - \text{Nodes}_{\text{AILS}}}{\text{Nodes}_{\text{A*}}} \times 100.
\end{equation}

\end{enumerate}

%----------------------------------------------------------------------
\subsection{Experimental Protocol}\label{subsec:protocol}
%----------------------------------------------------------------------

The experimental protocol was designed to ensure reproducibility and statistical rigour:

\textbf{Execution.} Each algorithm was executed on identical grids in both standard and corridor-based configurations. For DS1, all 2{,}000 maps per density were evaluated; for DS2--DS3, 100 random start--goal pairs per configuration were used.

\textbf{Repetitions.} Each instance was timed three times and the median execution time was recorded. Visited nodes and path length, being deterministic for a given map and start--goal pair, were recorded once.

\textbf{Random Seed Policy.} For the ILS experiments (DS1), a fixed global random seed was set at the beginning of each experimental run to ensure reproducibility of grid generation and start--goal pair sampling. For the AILS experiments (DS2--DS3), per-configuration seeds were recorded, with each grid-size--density--topology combination initialised from a deterministic seed derived from the configuration parameters. All seeds were documented in the experimental logs to enable exact reproduction of results.

\textbf{Statistical Validation (ILS Study).} For the ILS experiments (DS1), a paired $t$-test was performed to validate the significance of observed differences between standard and ILS-enhanced algorithms \citep{Elshahed2025ILS}.

\textbf{Statistical Validation (AILS Study).} For the AILS experiments (DS2--DS3), pairwise comparisons used two-sided paired $t$-tests (one per start--goal pair) with significance level $\alpha_{\text{stat}} = 0.05$. Effect sizes were reported as Cohen's $d$, following the standard thresholds: $|d| < 0.2$ (negligible), $0.2$--$0.5$ (small), $0.5$--$0.8$ (medium), $\geq 0.8$ (large). Normality of paired differences was assessed with Shapiro--Wilk tests. For multi-group comparisons, one-way ANOVA with Tukey HSD post-hoc correction was applied \citep{Elshahed2025AILS}.

\textbf{Aggregation.} Results were averaged across all maps within each density level (DS1) or across all start--goal pairs within each grid-size--density--topology combination (DS2--DS3).

%----------------------------------------------------------------------
\subsection{Hardware and Software}\label{subsec:hardware}
%----------------------------------------------------------------------

Two hardware configurations were used across the studies:

\begin{table}[htb!]
\centering
\caption{Hardware and Software Configurations}
\label{tab:hardware}
\begin{tabular}{|l|p{5.5cm}|p{5.5cm}|}
\hline
 & \textbf{ILS Study (DS1, DS4)} & \textbf{AILS Study (DS2, DS3)} \\
\hline
\textbf{Processor} & Apple M1 (MacBook Air, 2020) & Intel Core i7-12700K (3.6~GHz, 12 cores) \\
\hline
\textbf{Memory} & 8~GB RAM & 64~GB DDR5 RAM \\
\hline
\textbf{Operating System} & macOS Sonoma 14.5 & Ubuntu 22.04 LTS \\
\hline
\textbf{Language} & Python 3.8 & Python 3.10 (NumPy, SciPy) \\
\hline
\end{tabular}
\end{table}

The drone-based experiments (Pipeline~4) used an identical software environment to the AILS study (Python~3.10 on Ubuntu~22.04~LTS) running on the same Intel Core i7-12700K workstation, with ArduPilot SITL executing locally. The hardware configuration for the drone flight controller and communication interface is described in Chapter~\ref{chap:pipeline}.

The use of different hardware platforms across the two studies meant that absolute execution times were not directly comparable between the ILS and AILS experiments. Relative metrics (percentage improvement, node reduction, corridor efficiency) were hardware-independent and were used for cross-study comparisons.


%======================================================================
\section{Summary}\label{sec:meth_summary}
%======================================================================

This chapter presented the methodology adopted to investigate corridor-based pathfinding on grid maps. The research framework comprised four pipelines---Baseline, ILS, AILS, and Planning-to-Flight---sharing a common grid representation, preprocessing procedure, and evaluation protocol.

Section~\ref{sec:meth_data} described four datasets (DS1--DS4) spanning synthetic and real-world environments, with grid sizes from $50 \times 50$ to $500 \times 500$, obstacle densities from 10\% to 40\%, and five obstacle topologies. A nine-step preprocessing pipeline converted raw environments into binary occupancy grids suitable for all planning pipelines.

Section~\ref{sec:meth_components} formalised the shared algorithmic components: the grid representation and state space, two connectivity models (4-connected and 8-connected), admissible heuristic functions, five baseline search algorithms, the Bresenham line algorithm, the ILS uniform-width corridor, the AILS variable-width corridor with per-point density estimation, and the path reconstruction and post-processing procedures.

Section~\ref{sec:meth_adaptive} detailed the AILS multi-strategy selection mechanism (Base, Standard, and Predictive strategies) and the fallback expansion procedure that ensured search completeness.

Sections~\ref{sec:meth_ils_pipeline}--\ref{sec:meth_ails_pipeline} presented the three algorithmic pipelines: the ILS-enhanced pipeline with five algorithm-specific adaptations and incremental corridor expansion; the baseline pipeline providing unconstrained performance references; and the AILS pipeline with four-stage architecture, constrained search, and local fallback expansion.

Section~\ref{sec:meth_metrics} defined eight evaluation metrics and an experimental protocol incorporating paired $t$-tests, Cohen's $d$ effect sizes, Shapiro--Wilk normality checks, and ANOVA with Tukey HSD correction.

Chapter~\ref{chap:pipeline} describes the software implementation of the framework, including the Python codebase, the drone integration via DroneKit and ROS/MAVROS, and the experimental execution environment.
